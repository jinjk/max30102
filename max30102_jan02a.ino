#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/64df4a17-cf42-4cf6-a026-1ed3f29712c9 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  int bmp;
  int po2;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
#include <Wire.h>
#include "MAX30105.h"  //sparkfun MAX3010X library
#include "heartRate.h"
#include "thingProperties.h"

#define TIMETOBOOT 3000  // wait for this time(msec) to output SpO2
#define SCALE 88.0       //adjust to display heart beat and SpO2 in the same scale
#define MAX_SPO2 100.0
#define MIN_SPO2 80.0
#define SAMPLING 5       //if you want to see heart beat more precisely , set SAMPLING to 1
#define FINGER_ON 30000  // if red signal is lower than this , it indicates your finger is not on the sensor
#define MINIMUM_SPO2 80.0
#define FINGER_THRESTHOLD 50000

MAX30105 particleSensor;

//#define MAX30105 //if you have Sparkfun's MAX30105 breakout board , try #define MAX30105
const int SDA_pin = 4;   //Pin D5
const int SCL_pin = 15;  //Pin D6

// Method declaration
void readHeartBeatAndSPO2();


void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  Wire.begin(SDA_pin, SCL_pin);
  // Initialize sensor
  if (!particleSensor.begin(Wire, I2C_SPEED_FAST))  //Use default I2C port, 400kHz speed
  {
    Serial.println("MAX30102 was not found. Please check wiring/power/solder jumper at MH-ET LIVE MAX30102 board. ");
    while (1)
      ;
  }

  //Setup to sense a nice looking saw tooth on the plotter
  byte ledBrightness = 0x7F;  //Options: 0=Off to 255=50mA
  byte sampleAverage = 4;     //Options: 1, 2, 4, 8, 16, 32
  byte ledMode = 2;           //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green
  //Options: 1 = IR only, 2 = Red + IR on MH-ET LIVE MAX30102 board
  int sampleRate = 200;  //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200
  int pulseWidth = 411;  //Options: 69, 118, 215, 411
  int adcRange = 16384;  //Options: 2048, 4096, 8192, 16384
  // Set up the wanted parameters
  particleSensor.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange);  //Configure sensor with these settings

  xTaskCreate(readHeartBeatAndSPO2,   /* Task function. */
              "readHeartBeatAndSPO2", /* String with name of task. */
              10000,                  /* Stack size in bytes. */
              NULL,                   /* Parameter passed as input of the task */
              1,                      /* Priority of the task. */
              NULL);                  /* Task handle. */
}




void loop() {
  ArduinoCloud.update();
  // Your code here
}

const byte RATE_SIZE = 4; //Increase this for more averaging. 4 is good.
byte rates[RATE_SIZE]; //Array of heart rates
byte rateSpot = 0;
long lastBeat = 0; //Time at which the last beat occurred
float beatsPerMinute;
int beatAvg;
int hasFinger = false;
int ratesSize = 0;
void heartBeat(long irValue) {
  if (checkForBeat(irValue) == true)
  {
    if (irValue >= FINGER_THRESTHOLD != hasFinger) {
      beatsPerMinute = 0;
      beatAvg = 0;
      rateSpot = 0;
      lastBeat = 0;
      ratesSize = 0;
      memset(rates, 0, sizeof(rates));
    }
    if (irValue < FINGER_THRESTHOLD) {
      bmp = 0;
      return;
    }
    //We sensed a beat!
    long now = millis();
    long delta = now - lastBeat;
    lastBeat = now;

    beatsPerMinute = 60 / (delta / 1000.0);

    if (beatsPerMinute < 255 && beatsPerMinute > 20)
    {
      rates[rateSpot++] = (byte)roundf(beatsPerMinute); //Store this reading in the array
      rateSpot %= RATE_SIZE; //Wrap variable
      ratesSize = ++ratesSize >= RATE_SIZE ? RATE_SIZE : ratesSize;

      //Take average of readings
      beatAvg = 0;
      for (byte x = 0 ; x < RATE_SIZE ; x++)
        beatAvg += rates[x];
      beatAvg /= ratesSize;
      bmp = beatAvg;

    Serial.print(beatsPerMinute);  //low pass filtered SpO2
    Serial.print(",");
    Serial.println(beatAvg);
    }
  }
}

double avered = 0;
double aveir = 0;
double sumirrms = 0;
double sumredrms = 0;
int i = 0;
int Num = 100;  //calculate SpO2 by this sampling interval

double ESpO2 = 0.0;     //initial value of estimated SpO2
double FSpO2 = 0.7;      //filter factor for estimated SpO2
double frate = 0.95;     //low pass filter for IR/red LED value to eliminate AC component
void spo2(uint32_t &ir, uint32_t &red, double &fred, double &fir, double &SpO2) {
  if (ir >= FINGER_THRESTHOLD != hasFinger) {
    if (hasFinger) {
      ESpO2 = 0;
      particleSensor.nextSample();  //We're finished with this sample so move to next sample
    }
    else {
      ESpO2 = 95.0;
    }
  }
  if (ir < FINGER_THRESTHOLD) {
    po2 = 0;
    return;
  }

  i++;
  fred = (double)red;
  fir = (double)ir;
  avered = avered * frate + (double)red * (1.0 - frate);  //average red level by low pass filter
  aveir = aveir * frate + (double)ir * (1.0 - frate);     //average IR level by low pass filter
  sumredrms += (fred - avered) * (fred - avered);         //square sum of alternate component of red level
  sumirrms += (fir - aveir) * (fir - aveir);              //square sum of alternate component of IR level
  if ((i % Num) == 0) {
    double R = (sqrt(sumredrms) / avered) / (sqrt(sumirrms) / aveir);
    // Serial.println(R);
    SpO2 = -23.3 * (R - 0.4) + 100;                //http://ww1.microchip.com/downloads/jp/AppNotes/00001525B_JP.pdf
    ESpO2 = FSpO2 * ESpO2 + (1.0 - FSpO2) * SpO2;  //low pass filter
    sumredrms = 0.0;
    sumirrms = 0.0;
    i = 0;

    po2 = ESpO2;

    Serial.print(ESpO2);  //low pass filtered SpO2
    Serial.print(",");
    Serial.print(beatsPerMinute);  //low pass filtered SpO2
    Serial.print(",");
    Serial.println(beatAvg);
  }
}

void readHeartBeatAndSPO2(void *pvParameters) {

  uint32_t ir, red, green;
  double fred, fir;
  double SpO2 = 0;  //raw SpO2 before low pass filtered

  while (1) {
    particleSensor.check();  //Check the sensor, read up to 3 samples

    while (particleSensor.available()) {  //do we have new data
#ifdef MAX30105
      red = particleSensor.getFIFORed();  //Sparkfun's MAX30105
      ir = particleSensor.getFIFOIR();    //Sparkfun's MAX30105
#else
      red = particleSensor.getFIFOIR();  //why getFOFOIR output Red data by MAX30102 on MH-ET LIVE breakout board
      ir = particleSensor.getFIFORed();  //why getFIFORed output IR data by MAX30102 on MH-ET LIVE breakout board
#endif
      heartBeat(ir);
      spo2(ir, red, fred, fir, SpO2);
      hasFinger = ir >= FINGER_THRESTHOLD;
      particleSensor.nextSample();  //We're finished with this sample so move to next sample
      //Serial.println(SpO2);
    }
  }
}
